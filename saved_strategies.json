{
  "strategies": [
    {
      "id": "651vwp7yj",
      "name": "000N0N0 Sequencebot",
      "code": "const seq = data.digits.slice(-7).join('');\n\n// Pattern: XXX[diff]X[diff]X where X is target digit, diff is any different digit\nif (/000[^0]0[^0]0/.test(seq)) {\n    signal('DIGITDIFF', 1, 0);\n    log(`Strategy matched: 000N0N0 pattern (Sequence: ${seq})`);\n}\nif (/111[^1]1[^1]1/.test(seq)) {\n    signal('DIGITDIFF', 1, 1);\n    log(`Strategy matched: 111N1N1 pattern (Sequence: ${seq})`);\n}\nif (/222[^2]2[^2]2/.test(seq)) {\n    signal('DIGITDIFF', 1, 2);\n    log(`Strategy matched: 222N2N2 pattern (Sequence: ${seq})`);\n}\nif (/333[^3]3[^3]3/.test(seq)) {\n    signal('DIGITDIFF', 1, 3);\n    log(`Strategy matched: 333N3N3 pattern (Sequence: ${seq})`);\n}\nif (/444[^4]4[^4]4/.test(seq)) {\n    signal('DIGITDIFF', 1, 4);\n    log(`Strategy matched: 444N4N4 pattern (Sequence: ${seq})`);\n}\nif (/555[^5]5[^5]5/.test(seq)) {\n    signal('DIGITDIFF', 1, 5);\n    log(`Strategy matched: 555N5N5 pattern (Sequence: ${seq})`);\n}\nif (/666[^6]6[^6]6/.test(seq)) {\n    signal('DIGITDIFF', 1, 6);\n    log(`Strategy matched: 666N6N6 pattern (Sequence: ${seq})`);\n}\nif (/777[^7]7[^7]7/.test(seq)) {\n    signal('DIGITDIFF', 1, 7);\n    log(`Strategy matched: 777N7N7 pattern (Sequence: ${seq})`);\n}\nif (/888[^8]8[^8]8/.test(seq)) {\n    signal('DIGITDIFF', 1, 8);\n    log(`Strategy matched: 888N8N8 pattern (Sequence: ${seq})`);\n}\nif (/999[^9]9[^9]9/.test(seq)) {\n    signal('DIGITDIFF', 1, 9);\n    log(`Strategy matched: 999N9N9 pattern (Sequence: ${seq})`);\n}",
      "prompt": "",
      "createdAt": "2026-01-04T19:24:03.857Z"
    },
    {
      "id": "strictodd1",
      "name": "Strict Odd Reversal (10/12)",
      "code": "// Get full digit history\\nconst digits = data.digits;\\nconst total = digits.length;\\n\\n// Helper: Check if digit is ODD\\nconst isOdd = (d) => d % 2 !== 0;\\n\\n// Helper: Check if 'count' digits strictly match the end of the history\\n// AND the digit just before them does NOT match (ensures exact trigger)\\nconst isStrictStreak = (count) => {\\n    if (total < count + 1) return false; // Need history + 1 previous digit\\n    \\n    // 1. Check if last 'count' digits are ALL Odd\\n    const streak = digits.slice(-count);\\n    const streakIsOdd = streak.every(isOdd);\\n    \\n    // 2. Check if the digit BEFORE the streak is EVEN (Strict Start)\\n    const prevDigit = digits[total - count - 1]; // The digit just before the streak\\n    const prevIsEven = !isOdd(prevDigit);\\n    \\n    return streakIsOdd && prevIsEven;\\n};\\n\\n// --- LOGIC ---\\n\\n// 1. Exact 10-Odd Streak (Triggers only once at 10)\\nif (isStrictStreak(10)) {\\n    signal('DIGITEVEN', 0.35);\\n    log(`Matched: Strict 10 Streak (Last: ${data.lastDigit})`);\\n}\\n\\n// 2. Exact 12-Odd Streak (Triggers only once at 12)\\nif (isStrictStreak(12)) {\\n    signal('DIGITEVEN', 0.35); // You might want to increase stake here for recovery?\\n    log(`Matched: Strict 12 Streak (Last: ${data.lastDigit})`);\\n}",
      "prompt": "trade even, if the last 10 digits are odd, then the 12th odd",
      "createdAt": "2026-01-05T10:00:00.000Z"
    },
    {
      "id": "strictoverunder1",
      "name": "Strict Over/Under Reversal (8)",
      "code": "// Get full digit history\\nconst digits = data.digits;\\nconst total = digits.length;\\n\\n// Helper: Check if digit is SMALL (0-4)\\nconst isSmall = (d) => d <= 4;\\nconst isBig = (d) => d >= 5;\\n\\n// Helper: Strict Streak Checker\\nconst isStrictStreak = (count, type) => {\\n    if (total < count + 1) return false;\\n    \\n    const streak = digits.slice(-count);\\n    // Check specific type\\n    const checkFn = type === 'SMALL' ? isSmall : isBig;\\n    const streakMatch = streak.every(checkFn);\\n    \\n    // Strict Start Check (Previous digit must be opposite)\\n    const prevDigit = digits[total - count - 1];\\n    const prevIsOpposite = type === 'SMALL' ? !isSmall(prevDigit) : !isBig(prevDigit);\\n    \\n    return streakMatch && prevIsOpposite;\\n};\\n\\n// --- LOGIC ---\\n\\n// 1. Strict 8 Small Digits -> Trade OVER 4 (Big)\\nif (isStrictStreak(8, 'SMALL')) {\\n    signal('DIGITOVER', 0.35, 4); // Barrier 4 means > 4 (5,6,7,8,9 wins)\\n    log(`Matched: Strict 8 Small Streak (Last: ${data.lastDigit}) -> Trading OVER 4`);\\n}\\n\\n// 2. Strict 8 Big Digits -> Trade UNDER 5 (Small)\\nif (isStrictStreak(8, 'BIG')) {\\n    signal('DIGITUNDER', 0.35, 5); // Barrier 5 means < 5 (0,1,2,3,4 wins)\\n    log(`Matched: Strict 8 Big Streak (Last: ${data.lastDigit}) -> Trading UNDER 5`);\\n}",
      "prompt": "strict over/under reversal 8 streak",
      "createdAt": "2026-01-05T10:45:00.000Z"
    },
    {
      "id": "strictoddv2",
      "name": "Strict Odd Reversal V2",
      "code": "// Get full digit history\\nconst digits = data.digits;\\nconst total = digits.length;\\n\\n// Helper: Check if digit is ODD\\nconst isOdd = (d) => d % 2 !== 0;\\n\\n// --- LOGIC ---\\n// Need at least 12 digits of history\\nif (total >= 12) {\\n    // Get the last 12 digits\\n    const last12 = digits.slice(-12);\\n    \\n    // Check if digits 1-10 (positions 0-9) are ALL ODD\\n    const first10AreOdd = last12.slice(0, 10).every(isOdd);\\n    \\n    // Check if the 12th digit (position 11) is ODD\\n    const digit12IsOdd = isOdd(last12[11]);\\n    \\n    // TRIGGER: If first 10 are odd AND 12th is odd\\n    if (first10AreOdd && digit12IsOdd) {\\n        signal('DIGITEVEN', 0.35);\\n        log(`ðŸ”¥ MATCH! 10 Odds + 12th Odd -> Trading EVEN (11th was: ${last12[10]})`);\\n    }\\n}",
      "prompt": "wait for 10 consecutive odds, then if 12th is odd, trade even",
      "createdAt": "2026-01-05T12:17:00.000Z"
    }
  ]
}